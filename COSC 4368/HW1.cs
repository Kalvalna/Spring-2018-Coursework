/*  Name:  Paul Uy
 *  Assignment: HW1 - 8-puzzle Solver
 *  Language: C#
 *  Description: The board was shuffled by n moves generated by the random method. 
 *      The solution was solved using the Manhattan distance heuristic.             */

using System;
using System.Collections.Generic;
using System.Linq;

namespace solve_8_puzzle
{
    public enum Direction
    {
        Up,
        Down,
        Left,
        Right
    };

    class State
    {
        int currRow;
        int currCol;
        public int[,] nodes;
        public int fCost;
        public int gCost;
        public int hCost;
        public Direction previous;

        public State()
        {
            nodes = new int[,] { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } };
            currRow = 0;
            currCol = 0;
            gCost = 0;
        }

        public State(State state, Direction prev, Direction change, int g)
        {
            nodes = state.nodes.Clone() as int[,];
            currRow = state.currRow;
            currCol = state.currCol;
            Swap(change);
            previous = prev;
            gCost = g;
            hCost = CalcManhattan();
            fCost = gCost + hCost;
        }

        public bool CanMove(Direction dir)
        {
            if (dir == Direction.Up)
            {
                return currRow > 0;
            }
            else if (dir == Direction.Down)
            {
                return currRow < 2;
            }
            else if (dir == Direction.Left)
            {
                return currCol > 0;
            }
            else
            {
                return currCol < 2;
            }
        }

        public void PrintState()
        {
            Console.WriteLine("+board+");
            for (int i = 0; i < 3; i++)
            {
                Console.WriteLine("|{0}|{1}|{2}|", nodes[i, 0], nodes[i, 1], nodes[i, 2]);
            }
            Console.WriteLine("+-----+");
        }

        public void Shuffle(int n)
        {
            Random rand = new Random();
            for (int i = 0; i < n; i++)
            {
                int randDir = rand.Next(4);
                while (!CanMove((Direction)randDir))
                {
                    randDir = rand.Next(4);
                }
                Swap((Direction)randDir);
                PrintState();
            }
            hCost = CalcManhattan();
            fCost = gCost + hCost;
        }

        private int CalcManhattan()
        {
            int manDist = 0;
            int currentPos;

            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    currentPos = nodes[i, j];
                    switch (currentPos)
                    {
                        case 0:
                            manDist += Math.Abs(0 - i) + Math.Abs(0 - j);
                            break;
                        case 1:
                            manDist += Math.Abs(0 - i) + Math.Abs(1 - j);
                            break;
                        case 2:
                            manDist += Math.Abs(0 - i) + Math.Abs(2 - j);
                            break;
                        case 3:
                            manDist += Math.Abs(1 - i) + Math.Abs(0 - j);
                            break;
                        case 4:
                            manDist += Math.Abs(1 - i) + Math.Abs(1 - j);
                            break;
                        case 5:
                            manDist += Math.Abs(1 - i) + Math.Abs(2 - j);
                            break;
                        case 6:
                            manDist += Math.Abs(2 - i) + Math.Abs(0 - j);
                            break;
                        case 7:
                            manDist += Math.Abs(2 - i) + Math.Abs(1 - j);
                            break;
                        case 8:
                            manDist += Math.Abs(2 - i) + Math.Abs(2 - j);
                            break;
                    }
                }
            }
            return manDist;
        }

        private void Swap(Direction dir)
        {
            int temp = nodes[currRow, currCol];
            switch (dir)
            {
                case Direction.Up:
                    nodes[currRow, currCol] = nodes[currRow - 1, currCol];
                    nodes[currRow - 1, currCol] = temp;
                    currRow -= 1;
                    break;
                case Direction.Down:
                    nodes[currRow, currCol] = nodes[currRow + 1, currCol];
                    nodes[currRow + 1, currCol] = temp;
                    currRow += 1;
                    break;
                case Direction.Left:
                    nodes[currRow, currCol] = nodes[currRow, currCol - 1];
                    nodes[currRow, currCol - 1] = temp;
                    currCol -= 1;
                    break;
                case Direction.Right:
                    nodes[currRow, currCol] = nodes[currRow, currCol + 1];
                    nodes[currRow, currCol + 1] = temp;
                    currCol += 1;
                    break;
            }
        }
    }

    class Board
    {
        State state;
        List<State> open = new List<State>();
        List<State> closed = new List<State>();

        public Board()
        {
            state = new State();
        }

        public void PrintBoard()
        {
            state.PrintState();
        }

        public void ShuffleBoard(int n)
        {
            state.Shuffle(n);
        }

        public int SolveBoard()
        {
            open.Add(state);
            State current = open[0];
            List<State> sortedByF;
            Direction previous;

            while (current.hCost > 0)
            {
                sortedByF = open.OrderBy(x => x.fCost).ToList();
                current = sortedByF[0];
                closed.Add(current);
                open.Remove(current);
                for (int i = 0; i < 4; i++)
                {
                    if (CanMoveIn(current, (Direction)i) && (current.gCost == 0 || (Direction)i != current.previous))
                    {
                        switch (i)
                        {
                            case 0:
                                previous = (Direction)1;
                                open.Add(new State(current, previous, (Direction)i, current.gCost + 1));
                                break;
                            case 1:
                                previous = (Direction)0;
                                open.Add(new State(current, previous, (Direction)i, current.gCost + 1));
                                break;
                            case 2:
                                previous = (Direction)3;
                                open.Add(new State(current, previous, (Direction)i, current.gCost + 1));
                                break;
                            case 3:
                                previous = (Direction)2;
                                open.Add(new State(current, previous, (Direction)i, current.gCost + 1));
                                break;
                        }

                    }
                }
            }
            PrintSolution(closed, current, state);
            return current.gCost;
        }

        private bool CanMoveIn(State a, Direction dir)
        {
            return a.CanMove(dir);
        }

        private bool IsSame(State s1, State s2)
        {
            if (s1.gCost != s2.gCost) { return false; }
            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    if (s1.nodes[i, j] != s2.nodes[i, j]) { return false; }
                }
            }
            return true;
        }

        private void PrintSolution(List<State> allClosed, State current, State start)
        {
            List<State> solution = new List<State> { current };
            State last;
            while (!IsSame(current, start))
            {
                for (int i = 0; i < allClosed.Count; i++)
                {
                    last = new State(current, Direction.Up, current.previous, current.gCost - 1);
                    if (IsSame(allClosed[i], last))
                    {
                        current = allClosed[i];
                        solution.Add(current);
                        break;
                    }
                }
            }
            solution = solution.OrderBy(x => x.gCost).ToList();
            for (int i = 0; i < solution.Count; i++)
            {
                solution[i].PrintState();
            }
        }

    }

    class Solution
    {
        static void Main(string[] args)
        {
            Board board = new Board();
            board.PrintBoard();
            int nShuffle = new Random().Next(5, 20);
            board.ShuffleBoard(nShuffle);
            Console.WriteLine("Shuffle done, attempting to solve");
            int nMoves = board.SolveBoard();
            Console.WriteLine("Solution Length: {0} moves", nMoves);
            Console.WriteLine("Shuffle Length: {0} moves", nShuffle);
        }
    }
}
